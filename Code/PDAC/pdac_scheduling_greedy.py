"""
----- Calculate Job Power Schedules Using Greedy Heuristic -----

This program is designed to schedule a list of power jobs using a greedy heuristic algorithm. The algorithm is designed to schedule each job
in an interval that, at the time, would result in the lowest possible peak demand above the resource curve (PDAC). This algorithm's purpose
is to be used as a comparison tool to analyze the effectiveness of the more specialized ILP and relaxed LP programs. 
"""

import math

"""
----- Generate a list of viable power jobs -----

* generate_jobs -> This function takes in a random sample of jobs and returns a list of job objects. This function also selects 
*   these jobs based on the given input parameters
* 
* INPUTS
*   jobs_array (List) -> an unsorted list of all of the jobs available to the user
*   start_time (int) -> The time after which all jobs must start
*   end_time (int) -> The time by which all jobs must end
*   max_length (int) -> The maximum duration of a given job
*   batch_size (int) -> The size of the batch
* 
* ADDITIONAL
* This function will select the jobs based on the parameters. However, it should not select different jobs than other algorithms becuase they will all
* be provided with the same jobs_array list and parameters.
* Also, these jobs have an added field called 'flexible'. This is a measure of how flexibly a job can be scheduled. If a job has more viable intervals
* that it can be scheduled within, it is considered more flexible. 
* The list of jobs is sorted in ascending order of flexibility
"""
def generate_jobs(jobs_array, start_time, end_time, max_length, batch_size):
    jobs = []

    # Iterate through the job objects and create an array of objects that fall within the specified time window
    i = 0
    curr_index = 0
    while (i < batch_size):
        aj = jobs_array[curr_index]['release']
        dj = jobs_array[curr_index]['deadline']
        lj = jobs_array[curr_index]['length']

        # Calculate the flexibility measure
        fj = aj - dj - lj

        # Check if the specific job lies within the correct window
        # The funky syntax is used to put the job id at the very front of the dictionary
        if aj >= start_time and dj <= end_time and lj <= max_length:
            job_id = {"job_id" : i}

            flexibility = {'flexibility': fj}
            flexible_object = {**job_id, **flexibility, **jobs_array[curr_index]}
            jobs.append(flexible_object)
            
            i += 1
        
        curr_index += 1

    # Sort the jobs in ascending order based on their flexibility
    jobs = sorted(jobs, key=lambda job: job['flexibility']) 

    return jobs



"""
----- Generate a list of job intervals -----

* get_job_intervals -> This function is responsible for going through each of the jobs in the algorithm and returning all the intervals 
*   that the job could possibly run within
* 
* INPUTS
*   jobs (list) -> This is the list of jobs in this case
*   start_time (int) -> The earliest possible starting time for each job
"""
def get_job_intervals(jobs, start_time):
    intervals = [[] for _ in range(len(jobs))]
    for i, job in enumerate(jobs):
        # Extract the necessary information from the job object
        release = job['release'] - start_time
        deadline = job['deadline'] - start_time
        duration = job['length']
        num = release

        # Add the execution intervals to the sublist
        while (num + duration <= deadline):
            intervals[i].append((num, num + duration))
            num += 1
    
    return intervals



"""
----- Get the height of each job -----

* get_job_heights -> This function returns a list of the height of each respective job. The index of the job height corresponds to the 
*   jobs id
* 
* INPUTS
*   jobs (list) -> The list of jobs for the trial
"""
def get_job_heights(jobs):
    height = [job['height'] for job in jobs]

    return height


"""
----- Generate a greedy schedule ----- 

* generate_greedy_schedule -> This function takes in the jobs ordered by their flexibility and schedules them greedily based
*   on the amount of job area above the curve
* 
* INPUTS
*   intervals (list) -> the intervals during which each job can run
*   jobs (list) -> the list of jobs in the trial
*   num_time_steps -> the number of distinct time steps during the period
* 
* ADDITIONAL
* This function returns a list of height values across the entire time period. These are the heights generated by the greedy schedule
"""
def generate_greedy_schedule(jobs, resources, intervals, num_time_steps):
    final_heights = [0 for _ in range(num_time_steps)]
    final_intervals = []

    for job_id, interval_set in enumerate(intervals):
        best_score = float(-math.inf)
        best_interval = None

        job_height = jobs[job_id]['height']

        for interval in interval_set:
            interval_start, interval_end = interval[0], interval[1]

            # We want to find the max of this array above
            # because we are more concerned right now with PDAC
            score = max([resources[i] - final_heights[i] - job_height for i in range(interval_start, interval_end)])

            # If there is a larger difference between the combined heights of the current job, the previousbly scheduled jobs
            # and the resource curve at a given time step, then that interval is considered more greedily viable
            if score > best_score:
                best_score = score
                best_interval = interval

        # Generate the list of final heights based off of each best interval
        final_intervals.append(best_interval)
        for i in range(best_interval[0], best_interval[1]):
            final_heights[i] += job_height    
    
    return final_heights


"""
* solve_pdac_greedy -> This function calculates and returns the objective value for the greedy schedule
* 
* INPUTS 
*   jobs_array (list) -> An unfiltered array of all of the possible jobs available for scheduling
*   resources (list) -> A list of height values representing the amount of available resources at each discrete time step
*   start_time (int) -> The earliest possible starting time for each job
*   end_time (int) -> The latest possible ending time for each job
*   max_length (int) -> The maximum length of a given job
*   batch_size (int) -> The number of jobs that should be included in the schedule
"""
def solve_pdac_greedy(jobs_array, resources, start_time, end_time, max_length, batch_size):
    # Specify the number of time steps 
    num_time_steps = end_time - start_time

    # Generate the jobs
    jobs = generate_jobs(jobs_array, start_time, end_time, max_length, batch_size)

    # Generate the intervals
    intervals = get_job_intervals(jobs, start_time)

    # Get the list of final scheduled job heights
    final_heights = generate_greedy_schedule(jobs, resources, intervals, num_time_steps)

    # Calculate the final objective value (PDAC) based on these heights and the resource curve
    objective_value = 0
    for i, height in enumerate(final_heights):
        if height - resources[i] > objective_value:
            objective_value = height - resources[i]

    return (objective_value, final_heights)